import pytest
from cymple import QueryBuilder

qb = QueryBuilder()

rendered = {
    '_RESET_': qb.reset(),
    'CALL': qb.reset().call().procedure("db.labels()"),
    'CASE WHEN': qb.reset().match().node(ref_name='n').with_('n').case_when({'n.name': 'Bob'}, 'true', 'false', 'my_boolean'),
    'DELETE': qb.reset().match().node(ref_name='n').delete('n'),
    'DETACH DELETE': qb.reset().match().node(ref_name='n').detach_delete('n'),
    'WHERE (single)': qb.reset().match().node(ref_name='n').where('n.name', '=', 'value'),
    'WHERE (multiple)': qb.reset().match().node(ref_name='n').where_multiple({'n.name': 'value', 'n.age': 20}),
    'WHERE (literal)': qb.reset().match().node(ref_name='n').where_literal('NOT exists(n)'),
    'MATCH': qb.reset().match(),
    'MATCH OPTIONAL': qb.reset().match_optional(),
    'MERGE': qb.reset().merge(),
    'NODE': qb.reset().match().node(['label1', 'label2'], 'node', {'name': 'Bob'}),
    'NODE MERGE': qb.reset().merge().node(labels=['label1', 'label2'], ref_name='n', properties={'name': 'Bob'}).related_to().node(ref_name='m'),
    'NODE (not escaping)': qb.reset().match().node(['label1', 'label2'], 'node', {'name': 'Bob'}, escape=False),
    'OPERATOR': qb.reset().match().operator_start('SHORTESTPATH', 'p', '(:A)-[*]-(:B)').operator_end(),
    'RELATION (forward)': qb.reset().match().node().related_to().node(),
    'RELATION (backward)': qb.reset().match().node().related_from().node(),
    'RELATION (unidirectional)': qb.reset().match().node().related().node(),
    'RELATION (variable length)': qb.reset().match().node().related(min_hops=1, max_hops=2).node(),
    'RELATION (variable length, empty)': qb.reset().match().node().related(min_hops=-1, max_hops=-1).node(),
    'RELATION (variable length, with label)': qb.reset().match().node().related(label='Relation', ref_name='rel', min_hops=1, max_hops=2).node(),
    'RETURN (literal)': qb.reset().match().node(ref_name='n').return_literal('n'),
    'RETURN (mapping)': qb.reset().match().node(ref_name='n').return_mapping(('n.name', 'name')),
    'RETURN (mapping, list)': qb.reset().match().node(ref_name='n').return_mapping([('n.name', 'name'), ('n.age', 'age')]),
    'SET': qb.reset().merge().node(ref_name='n').set({'n.name': 'Alice'}),
    'SET (not escaping)': qb.reset().merge().node(ref_name='n').set({'n.name': 'n.name + "!"'}, escape_values=False),
    'SET (string)': qb.reset().merge().node(ref_name='n').set('n.name = n.name + "!"'),
    'ON CREATE': qb.reset().merge().node(ref_name='n').on_create().set({'n.name': 'Bob'}),
    'ON MATCH': qb.reset().merge().node(ref_name='n').on_match().set({'n.name': 'Bob'}),
    'ON CREATE ON MATCH': qb.reset().merge().node(ref_name='n').on_create().set({'n.name': 'Bob'}).on_match().set({'n.name': 'Alice'}),
    'ON MATCH ON CREATE': qb.reset().merge().node(ref_name='n').on_match().set({'n.name': 'Bob'}).on_create().set({'n.name': 'Alice'}),
    'UNWIND': qb.reset().match().node(ref_name='n').with_('n').unwind('n'),
    'WITH': qb.reset().match().node(ref_name='a').with_('a,b'),
    'WITH (start)': qb.reset().with_('a').match().node(ref_name='a').with_('a,b'),
    'YIELD': qb.reset().call().procedure("db.labels()").yield_(("label", "label")).where("label", "CONTAINS", "User").return_literal("count(label) AS numLabels"),
    'YIELD (list)': qb.reset().call().procedure("db.labels()").yield_([('length(labels)', 'len'), ('count(label)', 'cnt')]),
    'LIMIT': qb.reset().match().node(ref_name='n').return_literal('n').limit(1),
    'LIMIT (expression)': qb.reset().match().node(ref_name='n').return_literal('n').limit("1 + toInteger(3 * rand())"),
    'LIMIT (with)': qb.reset().match().node(ref_name='n').with_('n').limit(1),
    'LIMIT (with set)': qb.reset().match().node(ref_name='n').with_('n').limit(1).set({'n.name': 'Bob'}),
    'CYPHER': qb.reset().match().node(ref_name='n').cypher("my cypher").limit(1),
    'SKIP': qb.reset().match().node(ref_name='n').return_literal('n').skip(1),
    'SKIP (expression)': qb.reset().match().node(ref_name='n').return_literal('n').skip("1 + toInteger(3 * rand())"),
    'SKIP (with)': qb.reset().match().node(ref_name='n').with_('n').skip(1),
    'SKIP (with set)': qb.reset().match().node(ref_name='n').with_('n').skip(1).set({'n.name': 'Bob'}),
    'ORDER BY': qb.match().node(ref_name='n').return_literal('n.name, n.age').order_by("elementId(n)"),
    'ORDER BY (List)': qb.match().node(ref_name='n').return_literal('n.name, n.age').order_by(
        ["n.name", "keys(n)"]),
    'ORDER BY (Desc)': qb.match().node(ref_name='n').return_literal('n.name, n.age').order_by("n.name", False),
    'CREATE': qb.reset().create().node(ref_name='n').return_literal('n'),
    'REMOVE': qb.reset().match().node(ref_name='n').remove('n.name').return_literal('n.age, n.name'),
    'REMOVE (list)': qb.reset().match().node(ref_name='n').remove(['n.age', 'n.name']).return_literal('n.age, n.name'),
    'UNION': qb.match().node(ref_name='n', labels="Actor").return_mapping([('n.name', 'name')]).union().match().node(
        ref_name='n', labels="Movie").return_mapping([('n.title', 'name')]),
    'UNION (all)': qb.match().node(ref_name='n', labels="Actor").return_mapping(
        [('n.name', 'name')]).union_all().match().node(ref_name='n', labels="Movie").return_mapping([('n.title', 'name')]),
    'CASE (simple)': qb.match().node(ref_name="n", labels="Person").return_literal().case(when_then_mapping={"1": "'blue'", "2": ["'brown'", "'hazel'"]}, default_result="3", results_ref="result, n.eyes", test_expression="n.eyes"),
    'CASE (simple extended)': qb.match().node(ref_name="n", labels="Person").return_literal("n.name,").case(when_then_mapping={"'Unknown'": ["IS NULL", "IS NOT TYPED INTEGER | FLOAT"], "'Baby'": ["= 0", "= 1", "= 2"], "'Child'": "<= 13", "'Teenager'": "< 20", "'Young Adult'": "< 30", "'Immortal'": "> 1000"}, default_result="'Adult'", test_expression="n.age", results_ref="result"),
    'CASE (generic)': qb.match().node(ref_name="n", labels="Person").return_literal().case(when_then_mapping={"1": "n.eyes = 'blue'", "2": "n.age < 40"}, default_result="3", results_ref="result, n.eyes, n.age"),
    'CASE (null values)': qb.match().node(ref_name="n", labels="Person").return_literal("n.name,").case(when_then_mapping={"-1": "n.age IS NULL"}, default_result="n.age - 10", results_ref="age_10_years_ago"),
    'CASE (with set)': qb.match().node(ref_name="n", labels="Person").with_("n,").case(when_then_mapping={"1": "'blue'", "2": "'brown'"}, default_result="3", results_ref="colorCode", test_expression="n.eyes").set({"n.colorCode": "colorCode"}, escape_values=False).return_literal("n.name, n.colorCode")
}

expected = {
    '_RESET_': '',
    'CALL': 'CALL db.labels()',
    'CASE WHEN': 'MATCH (n) WITH n CASE WHEN n.name = "Bob" THEN true ELSE false END AS my_boolean',
    'DELETE': 'MATCH (n) DELETE n',
    'DETACH DELETE': 'MATCH (n) DETACH DELETE n',
    'WHERE (single)': 'MATCH (n) WHERE n.name = "value"',
    'WHERE (multiple)': 'MATCH (n) WHERE n.name = "value" AND n.age = 20',
    'WHERE (literal)': 'MATCH (n) WHERE NOT exists(n)',
    'MATCH': 'MATCH',
    'MATCH OPTIONAL': 'OPTIONAL MATCH',
    'MERGE': 'MERGE',
    'NODE': 'MATCH (node: label1: label2 {name : "Bob"})',
    'NODE MERGE': 'MERGE (n: label1: label2 {name : "Bob"})-->(m)',
    'NODE (not escaping)': 'MATCH (node: label1: label2 {name : Bob})',
    'OPERATOR': 'MATCH p = SHORTESTPATH( (:A)-[*]-(:B) )',
    'RELATION (forward)': 'MATCH ()-->()',
    'RELATION (backward)': 'MATCH ()<--()',
    'RELATION (unidirectional)': 'MATCH ()--()',
    'RELATION (variable length)': 'MATCH ()-[*1..2]-()',
    'RELATION (variable length, empty)': 'MATCH ()-[*]-()',
    'RELATION (variable length, with label)': 'MATCH ()-[rel: Relation*1..2]-()',
    'RETURN (literal)': 'MATCH (n) RETURN n',
    'RETURN (mapping)': 'MATCH (n) RETURN n.name AS name',
    'RETURN (mapping, list)': 'MATCH (n) RETURN n.name AS name, n.age AS age',
    'SET': 'MERGE (n) SET n.name = "Alice"',
    'SET (not escaping)': 'MERGE (n) SET n.name = n.name + "!"',
    'SET (string)': 'MERGE (n) SET n.name = n.name + "!"',
    'ON CREATE': 'MERGE (n) ON CREATE SET n.name = "Bob"',
    'ON MATCH': 'MERGE (n) ON MATCH SET n.name = "Bob"',
    'ON CREATE ON MATCH': 'MERGE (n) ON CREATE SET n.name = "Bob" ON MATCH SET n.name = "Alice"',
    'ON MATCH ON CREATE': 'MERGE (n) ON MATCH SET n.name = "Bob" ON CREATE SET n.name = "Alice"',
    'UNWIND': 'MATCH (n) WITH n UNWIND n',
    'WITH': 'MATCH (a) WITH a,b',
    'WITH (start)': 'WITH a MATCH (a) WITH a,b',
    'YIELD': 'CALL db.labels() YIELD label AS label WHERE label CONTAINS "User" RETURN count(label) AS numLabels',
    'YIELD (list)': 'CALL db.labels() YIELD length(labels) AS len, count(label) AS cnt',
    'LIMIT': 'MATCH (n) RETURN n LIMIT 1',
    'LIMIT (expression)': 'MATCH (n) RETURN n LIMIT 1 + toInteger(3 * rand())',
    'LIMIT (with)': 'MATCH (n) WITH n LIMIT 1',
    'LIMIT (with set)': 'MATCH (n) WITH n LIMIT 1 SET n.name = "Bob"',
    'CYPHER': 'MATCH (n) my cypher LIMIT 1',
    'SKIP': 'MATCH (n) RETURN n SKIP 1',
    'SKIP (expression)': 'MATCH (n) RETURN n SKIP 1 + toInteger(3 * rand())',
    'SKIP (with)': 'MATCH (n) WITH n SKIP 1',
    'SKIP (with set)': 'MATCH (n) WITH n SKIP 1 SET n.name = "Bob"',
    'ORDER BY': 'MATCH (n) RETURN n.name, n.age ORDER BY elementId(n) ASC',
    'ORDER BY (List)': 'MATCH (n) RETURN n.name, n.age ORDER BY n.name, keys(n) ASC',
    'ORDER BY (Desc)': 'MATCH (n) RETURN n.name, n.age ORDER BY n.name DESC',
    'CREATE': 'CREATE (n) RETURN n',
    'REMOVE': 'MATCH (n) REMOVE n.name RETURN n.age, n.name',
    'REMOVE (list)': 'MATCH (n) REMOVE n.age, n.name RETURN n.age, n.name',
    'UNION': 'MATCH (n: Actor) RETURN n.name AS name UNION MATCH (n: Movie) RETURN n.title AS name',
    'UNION (all)': 'MATCH (n: Actor) RETURN n.name AS name UNION ALL MATCH (n: Movie) RETURN n.title AS name',
    'CASE (simple)': "MATCH (n: Person) RETURN CASE n.eyes WHEN 'blue' THEN 1 WHEN 'brown', 'hazel' THEN 2 ELSE 3 END"
                     " AS result, n.eyes",
    'CASE (simple extended)': "MATCH (n: Person) RETURN n.name, CASE n.age WHEN IS NULL, IS NOT TYPED INTEGER | FLOAT"
                              " THEN 'Unknown' WHEN = 0, = 1, = 2 THEN 'Baby' WHEN <= 13 THEN 'Child' WHEN < 20 THEN"
                              " 'Teenager' WHEN < 30 THEN 'Young Adult' WHEN > 1000 THEN 'Immortal' ELSE 'Adult' END"
                              " AS result",
    'CASE (generic)': "MATCH (n: Person) RETURN CASE WHEN n.eyes = 'blue' THEN 1 WHEN n.age < 40 THEN 2 ELSE 3 END"
                      " AS result, n.eyes, n.age",
    'CASE (null values)': "MATCH (n: Person) RETURN n.name, CASE WHEN n.age IS NULL THEN -1 ELSE n.age - 10 END"
                          " AS age_10_years_ago",
    'CASE (with set)': "MATCH (n: Person) WITH n, CASE n.eyes WHEN 'blue' THEN 1 WHEN 'brown' THEN 2 ELSE 3 END "
                       "AS colorCode SET n.colorCode = colorCode RETURN n.name, n.colorCode"
}


@pytest.mark.parametrize('clause', expected)
def test_case(clause: str):
    assert str(rendered[clause]) == expected[clause]
